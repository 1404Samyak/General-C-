1)C++_Basics:
  Syntax:
    Function_Declaration: "return_type function_name(parameters) { /* code */ }"
    If_Else: |
      if (condition) {
        // code
      } else {
        // code
      }
    Loops:
      For: "for (int i = 0; i < n; i++)"
      While: "while (condition) { }"
      Do_While: "do { } while (condition);"

  Pointers_And_References:
    Pointer:
      Declaration: "int* p = &x;"
      Meaning: "'p' stores address of 'x'"
      Dereference: "*p gives value at the address"
    Reference:
      Declaration: "int& ref = x;"
      Meaning: "'ref' is another name for 'x', changes reflect both ways"

  Comparators:
    Custom_Sort_Vector:
      Code: |
        bool cmp(pair<int,int> a, pair<int,int> b) {
          return a.first > b.first; // descending
        }
        sort(vec.begin(), vec.end(), cmp);
      Use: "Custom sorting logic in STL algorithms"

  Vector:
    Declaration: "vector<int> v;"
    Common_Operations:
      Push_Back: "v.push_back(x);"
      Access: "v[i], v.at(i)"
      Size: "v.size()"
      Back: "v.back()"
      Front: "v.front()"
      Pop_Back: "v.pop_back();"
      Clear: "v.clear();"

  Stack:
    Header: "#include<stack>"
    Operations:
      Declaration: "stack<int> s;"
      Push: "s.push(x);"
      Pop: "s.pop();"
      Top: "s.top();"
      Size: "s.size();"
      Empty: "s.empty();"

  Queue:
    Header: "#include<queue>"
    Operations:
      Declaration: "queue<int> q;"
      Push: "q.push(x);"
      Pop: "q.pop();"
      Front: "q.front();"
      Back: "q.back();"
      Size: "q.size();"
      Empty: "q.empty();"

  Priority_Queue:
    Max_Heap: "priority_queue<int> pq;"
    Min_Heap: |
      priority_queue<int, vector<int>, greater<int>> pq;
    Custom_Comparator: |
      struct cmp {
        bool operator()(pair<int,int>& a, pair<int,int>& b) {
          return a.second > b.second;
        }
      };
      priority_queue<pair<int,int>, vector<pair<int,int>>, cmp> pq;

  Nested_Loops:
    Basic_Syntax: |
      for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
          // code using i, j
        }
      }
    Use_Cases:
      Matrix_Traversal: "For 2D matrix/grid problems"
      Subarray_Sum: |
        for(int i = 0; i < n; i++) {
          int sum = 0;
          for(int j = i; j < n; j++) {
            sum += arr[j];
            // process sum(i..j)
          }
        }
      Adjacency_Checking: |
        for(int u = 0; u < n; u++) {
          for(auto v : adj[u]) {
            // process edge u -> v
          }
        }
      Prefix_Sum_2D: |
        for(int i = 0; i < n; i++)
          for(int j = 0; j < m; j++)
            sum[i][j] = A[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];

  Complex_Declarations:
    Adjacency_List:
      Undirected_Graph: "vector<vector<int>> adj(n);"
      Weighted_Graph: "vector<vector<pair<int,int>>> adj(n); // {v, wt}"
      3D_Adjacency: "vector<vector<vector<pair<int,int>>>> graph;"
    Vector_of_Pairs: "vector<pair<int,int>> vp;"
    Vector_of_Vector_of_Pairs: "vector<vector<pair<int,int>>> vvp;"
    Set_of_Pairs: "set<pair<int,int>> s;"
    Map:
      Frequency_Map: "map<int,int> freq;"
      Char_Map: "unordered_map<char,int> m;"

  Notes:
    STL_Usage:
      - "Always use pass-by-reference in loops: for(auto &x : vec)"
      - "Vectors are dynamic, arrays are static"
    Tips:
      - "Prefer vector over array for flexibility"
      - "Use nested loops for pairwise comparisons, prefix/suffix logic, grid traversal"

2)Check_Valid_Parentheses:
  Purpose: "Check if a given string of parentheses is valid (balanced and properly nested)."

  Functions:
    match:
      Signature: "bool match(char ch1, char ch2)"
      Purpose: "Checks if the two characters form a valid opening-closing bracket pair."
      Logic:
        - "'(' matches with ')'"
        - "'{' matches with '}'"
        - "'[' matches with ']'"
      Return: "true if the pair is valid, else false"

    checkValidString:
      Signature: "bool checkValidString(string s)"
      Purpose: "Check if the input string `s` has valid and balanced brackets using a stack."

      Steps:
        1. Initialize a stack:
          Code: "stack<char> st;"
          Reason: "To keep track of unmatched opening brackets"
        
        2. Loop through each character in the string:
          Loop: "for (int i = 0; i < n; i++)"

          Cases:
            - If current character is a closing bracket: ')', '}', or ']':
                Conditions:
                  - If stack is empty:
                      Meaning: "No opening bracket to match with this closing bracket"
                      Action: "return false"
                  - Else, check if top of stack matches:
                      Logic: "match(st.top(), s[i])"
                      If true: "Pop from stack (valid pair found)"
                      Else: "return false (mismatched brackets)"
            
            - Else: (opening bracket):
                Action: "Push it onto the stack"
                Reason: "To wait for its corresponding closing bracket later"

        3. Final Stack Check:
          Code: "return st.empty();"
          Meaning: 
            -After the for loop is processed fully there is chance opening brackets may be left,for sure Only opening brackets are possible to be leftbehind not closing brackets because all closing brackets we are processig inside the for loop only.So if any opening brackets are left then also retur false,else return true
            - "If stack is empty: All brackets matched properly → return true"
            - "If stack is not empty: Some opening brackets were not closed → return false"

  Example_Run:
    Input: "({[]})"
    Stack_Trace:
      - Push '('
      - Push '{'
      - Push '['
      - Match '[' and ']' → pop
      - Match '{' and '}' → pop
      - Match '(' and ')' → pop
    Final_Stack: "empty → return true"

  Edge_Cases:
    - Input: "([)]"
      Explanation: "Although brackets are balanced in number, nesting is invalid → return false"
    - Input: "(()"
      Explanation: "Missing closing bracket for one opening → return false"
    - Input: "" (empty string)
      Explanation: "Technically balanced → return true"

  Notes:
    - Time_Complexity: "O(n)"
    - Space_Complexity: "O(n) in worst case (all openings)"
    - Only works for '(', ')', '{', '}', '[', ']' — doesn't support wildcards like '*'

  Optional_Extensions:
    - Support wildcard '*' as either '(' or ')' or empty (like in Leetcode problem)
    - Count total matched pairs
    - Return position of error for debugging

3)Valid_Parenthesis_With_Star:
  Problem:
    Statement: |
      Check whether a given string with characters '(', ')', and '*' is valid.
      '*' can represent either '(', ')' or an empty string.
    Goal: |
      Return true if the string can be interpreted as a valid sequence of parentheses.

  Core_Logic:
    Stacks_Used:
      open:
        Description: "Stores indices of unmatched '(' characters"
      star:
        Description: "Stores indices of '*' characters (can act as '(', ')' or empty)"
    
    Main_Loop:
      Iterate_Over_String:
        Code: |
          for (int i = 0; i < n; i++) {
              if (s[i] == '(') open.push(i);
              else if (s[i] == '*') star.push(i);
              else {
                  if (!open.empty()) open.pop();
                  else if (!star.empty()) star.pop();
                  else return false;
              }
          }
        Purpose:
          - Push index of '(' to open stack
          - Push index of '*' to star stack
          - When ')' is encountered:
              - First try to match with a previous '('
              - Else use '*' as '('
              - Else return false (no matching opening)
    
    Post_Loop_Compensation:
      Why_Needed: |
        After the loop, unmatched '(' may still remain in the open stack.
        These need to be matched using '*' treated as ')'.
        But only if '*' appeared **after** the '(' in the string.
      Code: |
        while (!open.empty() && !star.empty()) {
            if (open.top() > star.top()) return false;
            open.pop();
            star.pop();
        }
      Reasoning:
        - '(' at a later index than '*' means '*' appeared too early to act as ')'
        - So such combinations are invalid

    Final_Return:
      Code: |
        return open.empty();
      Meaning:
        - If all '(' were matched (directly or via '*'), return true
        - If any unmatched '(', return false

  Dry_Run_Example:
    Input: "(*))"
    Stack_States:
      Step_1: '(' at 0 → open = [0]
      Step_2: '*' at 1 → star = [1]
      Step_3: ')' at 2 → match with '(' → open.pop()
      Step_4: ')' at 3 → no '(', match with '*' → star.pop()
    Final: both stacks empty → ✅ valid

    Input: "*)("
    Stack_States:
      Step_1: '*' at 0 → star = [0]
      Step_2: ')' at 1 → no '(', match with '*' → star.pop()
      Step_3: '(' at 2 → open = [2]
    Final: open = [2], star = [] → ❌ invalid

  Time_Complexity: "O(n)"
  Space_Complexity: "O(n)"
  Constraints:
    - Only supports '(', ')', and '*'
    - Does not support '{' or '[' types of brackets

  Notes:
    - Clever use of indices allows enforcing correct ordering
    - The problem is based on Leetcode 678: Valid Parenthesis String
    - This greedy two-stack method is more efficient than backtracking all '*' cases

4)problem: Maximum Number of Non-Overlapping Meetings

constraints:
  - You are given two arrays: start[i], end[i] of size n
  - You must select the maximum number of meetings such that:
    - No two selected meetings overlap
    - The start time of a meeting must be strictly greater than the end time of the last selected meeting

solution_type: Greedy Algorithm

key_observation:
  - To schedule the maximum number of non-overlapping meetings, you should always choose the meeting that ends the earliest
  - This leaves the most room for future meetings

why_sort_by_end_time:
  - If you sort by end time, you always consider the meeting that finishes earliest first
  - This minimizes the time blocked by the current meeting
  - It ensures you leave space for as many future meetings as possible
  - This is optimal because picking a later-ending meeting might block a lot of shorter earlier-starting meetings

comparator_used:
  syntax: |
    sort(v.begin(), v.end(), [](pair<int, int>& p1, pair<int, int>& p2) {
        return p1.second <= p2.second;
    });

  explanation:
    - For two pairs p1 and p2 representing (start, end) of meetings:
      - If p1.second < p2.second → p1 comes before p2 ✅
      - If p1.second == p2.second → p1 comes before p2 (allowed because <= is true)
      - No explicit tie-breaking is used, but it doesn't matter for greedy correctness
    - This sort places meetings with the earliest end times at the front
    - Even if some meetings have the same end time, any one of them is safe to consider first

greedy_selection:
  - Initialize endtime = -infinity (or 0)
  - Traverse the sorted meetings
  - For each meeting:
      if start > endtime:
        - select the meeting
        - update endtime = current meeting's end
  - This ensures strictly non-overlapping selection

correctness_reasoning:
  - Greedy always picks the next meeting that ends the soonest
  - Once picked, no earlier-ending meeting could have been selected (because you already processed them)
  - By always choosing the best local (earliest ending) option, the global (maximum count) is achieved
  - This has been proven correct for the interval scheduling maximization problem

time_complexity:
  sorting: O(n log n)
  greedy_selection: O(n)
  total: O(n log n)

space_complexity: O(n) due to pair storage, O(1) if in-place sorting used

note:
  - If problem allows start == end, use '>='
  - If problem requires strict non-overlap (start > end), use '>'

