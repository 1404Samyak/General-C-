1)C++_Basics:
  Syntax:
    Function_Declaration: "return_type function_name(parameters) { /* code */ }"
    If_Else: |
      if (condition) {
        // code
      } else {
        // code
      }
    Loops:
      For: "for (int i = 0; i < n; i++)"
      While: "while (condition) { }"
      Do_While: "do { } while (condition);"

  Pointers_And_References:
    Pointer:
      Declaration: "int* p = &x;"
      Meaning: "'p' stores address of 'x'"
      Dereference: "*p gives value at the address"
    Reference:
      Declaration: "int& ref = x;"
      Meaning: "'ref' is another name for 'x', changes reflect both ways"

  Comparators:
    Custom_Sort_Vector:
      Code: |
        bool cmp(pair<int,int> a, pair<int,int> b) {
          return a.first > b.first; // descending
        }
        sort(vec.begin(), vec.end(), cmp);
      Use: "Custom sorting logic in STL algorithms"

  Vector:
    Declaration: "vector<int> v;"
    Common_Operations:
      Push_Back: "v.push_back(x);"
      Access: "v[i], v.at(i)"
      Size: "v.size()"
      Back: "v.back()"
      Front: "v.front()"
      Pop_Back: "v.pop_back();"
      Clear: "v.clear();"

  Stack:
    Header: "#include<stack>"
    Operations:
      Declaration: "stack<int> s;"
      Push: "s.push(x);"
      Pop: "s.pop();"
      Top: "s.top();"
      Size: "s.size();"
      Empty: "s.empty();"

  Queue:
    Header: "#include<queue>"
    Operations:
      Declaration: "queue<int> q;"
      Push: "q.push(x);"
      Pop: "q.pop();"
      Front: "q.front();"
      Back: "q.back();"
      Size: "q.size();"
      Empty: "q.empty();"

  Priority_Queue:
    Max_Heap: "priority_queue<int> pq;"
    Min_Heap: |
      priority_queue<int, vector<int>, greater<int>> pq;
    Custom_Comparator: |
      struct cmp {
        bool operator()(pair<int,int>& a, pair<int,int>& b) {
          return a.second > b.second;
        }
      };
      priority_queue<pair<int,int>, vector<pair<int,int>>, cmp> pq;

  Nested_Loops:
    Basic_Syntax: |
      for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
          // code using i, j
        }
      }
    Use_Cases:
      Matrix_Traversal: "For 2D matrix/grid problems"
      Subarray_Sum: |
        for(int i = 0; i < n; i++) {
          int sum = 0;
          for(int j = i; j < n; j++) {
            sum += arr[j];
            // process sum(i..j)
          }
        }
      Adjacency_Checking: |
        for(int u = 0; u < n; u++) {
          for(auto v : adj[u]) {
            // process edge u -> v
          }
        }
      Prefix_Sum_2D: |
        for(int i = 0; i < n; i++)
          for(int j = 0; j < m; j++)
            sum[i][j] = A[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];

  Complex_Declarations:
    Adjacency_List:
      Undirected_Graph: "vector<vector<int>> adj(n);"
      Weighted_Graph: "vector<vector<pair<int,int>>> adj(n); // {v, wt}"
      3D_Adjacency: "vector<vector<vector<pair<int,int>>>> graph;"
    Vector_of_Pairs: "vector<pair<int,int>> vp;"
    Vector_of_Vector_of_Pairs: "vector<vector<pair<int,int>>> vvp;"
    Set_of_Pairs: "set<pair<int,int>> s;"
    Map:
      Frequency_Map: "map<int,int> freq;"
      Char_Map: "unordered_map<char,int> m;"

  Notes:
    STL_Usage:
      - "Always use pass-by-reference in loops: for(auto &x : vec)"
      - "Vectors are dynamic, arrays are static"
    Tips:
      - "Prefer vector over array for flexibility"
      - "Use nested loops for pairwise comparisons, prefix/suffix logic, grid traversal"

2)Check_Valid_Parentheses:
  Purpose: "Check if a given string of parentheses is valid (balanced and properly nested)."

  Functions:
    match:
      Signature: "bool match(char ch1, char ch2)"
      Purpose: "Checks if the two characters form a valid opening-closing bracket pair."
      Logic:
        - "'(' matches with ')'"
        - "'{' matches with '}'"
        - "'[' matches with ']'"
      Return: "true if the pair is valid, else false"

    checkValidString:
      Signature: "bool checkValidString(string s)"
      Purpose: "Check if the input string `s` has valid and balanced brackets using a stack."

      Steps:
        1. Initialize a stack:
          Code: "stack<char> st;"
          Reason: "To keep track of unmatched opening brackets"
        
        2. Loop through each character in the string:
          Loop: "for (int i = 0; i < n; i++)"

          Cases:
            - If current character is a closing bracket: ')', '}', or ']':
                Conditions:
                  - If stack is empty:
                      Meaning: "No opening bracket to match with this closing bracket"
                      Action: "return false"
                  - Else, check if top of stack matches:
                      Logic: "match(st.top(), s[i])"
                      If true: "Pop from stack (valid pair found)"
                      Else: "return false (mismatched brackets)"
            
            - Else: (opening bracket):
                Action: "Push it onto the stack"
                Reason: "To wait for its corresponding closing bracket later"

        3. Final Stack Check:
          Code: "return st.empty();"
          Meaning: 
            -After the for loop is processed fully there is chance opening brackets may be left,for sure Only opening brackets are possible to be leftbehind not closing brackets because all closing brackets we are processig inside the for loop only.So if any opening brackets are left then also retur false,else return true
            - "If stack is empty: All brackets matched properly → return true"
            - "If stack is not empty: Some opening brackets were not closed → return false"

  Example_Run:
    Input: "({[]})"
    Stack_Trace:
      - Push '('
      - Push '{'
      - Push '['
      - Match '[' and ']' → pop
      - Match '{' and '}' → pop
      - Match '(' and ')' → pop
    Final_Stack: "empty → return true"

  Edge_Cases:
    - Input: "([)]"
      Explanation: "Although brackets are balanced in number, nesting is invalid → return false"
    - Input: "(()"
      Explanation: "Missing closing bracket for one opening → return false"
    - Input: "" (empty string)
      Explanation: "Technically balanced → return true"

  Notes:
    - Time_Complexity: "O(n)"
    - Space_Complexity: "O(n) in worst case (all openings)"
    - Only works for '(', ')', '{', '}', '[', ']' — doesn't support wildcards like '*'

  Optional_Extensions:
    - Support wildcard '*' as either '(' or ')' or empty (like in Leetcode problem)
    - Count total matched pairs
    - Return position of error for debugging

3)Valid_Parenthesis_With_Star:
  Problem:
    Statement: |
      Check whether a given string with characters '(', ')', and '*' is valid.
      '*' can represent either '(', ')' or an empty string.
    Goal: |
      Return true if the string can be interpreted as a valid sequence of parentheses.

  Core_Logic:
    Stacks_Used:
      open:
        Description: "Stores indices of unmatched '(' characters"
      star:
        Description: "Stores indices of '*' characters (can act as '(', ')' or empty)"
    
    Main_Loop:
      Iterate_Over_String:
        Code: |
          for (int i = 0; i < n; i++) {
              if (s[i] == '(') open.push(i);
              else if (s[i] == '*') star.push(i);
              else {
                  if (!open.empty()) open.pop();
                  else if (!star.empty()) star.pop();
                  else return false;
              }
          }
        Purpose:
          - Push index of '(' to open stack
          - Push index of '*' to star stack
          - When ')' is encountered:
              - First try to match with a previous '('
              - Else use '*' as '('
              - Else return false (no matching opening)
    
    Post_Loop_Compensation:
      Why_Needed: |
        After the loop, unmatched '(' may still remain in the open stack.
        These need to be matched using '*' treated as ')'.
        But only if '*' appeared **after** the '(' in the string.
      Code: |
        while (!open.empty() && !star.empty()) {
            if (open.top() > star.top()) return false;
            open.pop();
            star.pop();
        }
      Reasoning:
        - '(' at a later index than '*' means '*' appeared too early to act as ')'
        - So such combinations are invalid

    Final_Return:
      Code: |
        return open.empty();
      Meaning:
        - If all '(' were matched (directly or via '*'), return true
        - If any unmatched '(', return false

  Dry_Run_Example:
    Input: "(*))"
    Stack_States:
      Step_1: '(' at 0 → open = [0]
      Step_2: '*' at 1 → star = [1]
      Step_3: ')' at 2 → match with '(' → open.pop()
      Step_4: ')' at 3 → no '(', match with '*' → star.pop()
    Final: both stacks empty → ✅ valid

    Input: "*)("
    Stack_States:
      Step_1: '*' at 0 → star = [0]
      Step_2: ')' at 1 → no '(', match with '*' → star.pop()
      Step_3: '(' at 2 → open = [2]
    Final: open = [2], star = [] → ❌ invalid

  Time_Complexity: "O(n)"
  Space_Complexity: "O(n)"
  Constraints:
    - Only supports '(', ')', and '*'
    - Does not support '{' or '[' types of brackets

  Notes:
    - Clever use of indices allows enforcing correct ordering
    - The problem is based on Leetcode 678: Valid Parenthesis String
    - This greedy two-stack method is more efficient than backtracking all '*' cases

4)problem: Maximum Number of Non-Overlapping Meetings

constraints:
  - You are given two arrays: start[i], end[i] of size n
  - You must select the maximum number of meetings such that:
    - No two selected meetings overlap
    - The start time of a meeting must be strictly greater than the end time of the last selected meeting

solution_type: Greedy Algorithm

key_observation:
  - To schedule the maximum number of non-overlapping meetings, you should always choose the meeting that ends the earliest
  - This leaves the most room for future meetings

why_sort_by_end_time:
  - If you sort by end time, you always consider the meeting that finishes earliest first
  - This minimizes the time blocked by the current meeting
  - It ensures you leave space for as many future meetings as possible
  - This is optimal because picking a later-ending meeting might block a lot of shorter earlier-starting meetings

comparator_used:
  syntax: |
    sort(v.begin(), v.end(), [](pair<int, int>& p1, pair<int, int>& p2) {
        return p1.second <= p2.second;
    });

  explanation:
    - For two pairs p1 and p2 representing (start, end) of meetings:
      - If p1.second < p2.second → p1 comes before p2 ✅
      - If p1.second == p2.second → p1 comes before p2 (allowed because <= is true)
      - No explicit tie-breaking is used, but it doesn't matter for greedy correctness
    - This sort places meetings with the earliest end times at the front
    - Even if some meetings have the same end time, any one of them is safe to consider first

greedy_selection:
  - Initialize endtime = -infinity (or 0)
  - Traverse the sorted meetings
  - For each meeting:
      if start > endtime:
        - select the meeting
        - update endtime = current meeting's end
  - This ensures strictly non-overlapping selection

correctness_reasoning:
  - Greedy always picks the next meeting that ends the soonest
  - Once picked, no earlier-ending meeting could have been selected (because you already processed them)
  - By always choosing the best local (earliest ending) option, the global (maximum count) is achieved
  - This has been proven correct for the interval scheduling maximization problem

time_complexity:
  sorting: O(n log n)
  greedy_selection: O(n)
  total: O(n log n)

space_complexity: O(n) due to pair storage, O(1) if in-place sorting used

note:
  - If problem allows start == end, use '>='
  - If problem requires strict non-overlap (start > end), use '>'

5)problem: Merge Overlapping Intervals

description: |
  Given a list of intervals where each interval is a pair [start, end],
  merge all overlapping intervals and return a list of non-overlapping intervals
  that cover all the input intervals.

approach: Greedy Merge

sorting_step:
  reason: |
    To easily detect overlapping intervals, we must process them in order of their start times.
    Sorting by start time ensures all overlapping intervals are adjacent in the list.
  code_snippet: |
    sort(intervals.begin(), intervals.end());

variables:
  - n: number of intervals
  - ans: list to store the merged, non-overlapping intervals

main_loop:
  iteration: for each interval in intervals
  logic:
    - if ans is empty:
        - this is the first interval, add it to ans
    - else if current interval does NOT overlap with last interval in ans:
        - check: interval[0] > ans.back()[1]
        - reasoning: if current start > last end, no overlap exists
        - action: push current interval into ans
    - else if current interval overlaps with last interval in ans:
        - merge by updating end time
        - new_end = max(current_end, ans.back()[1])

  code_snippet: |
    for (auto interval : intervals) {
        if (ans.empty())
            ans.push_back(interval);
        else if (interval[0] > ans.back()[1])
            ans.push_back(interval);
        else
            ans.back()[1] = max(ans.back()[1], interval[1]);
    }

final_return:
  - return the list of merged intervals
  code_snippet: |
    return ans;

example_dry_run:
  input: [[1,3], [2,6], [8,10], [15,18]]
  sorted: [[1,3], [2,6], [8,10], [15,18]]
  steps:
    - [1,3] → ans = [[1,3]]
    - [2,6] overlaps → merge → ans = [[1,6]]
    - [8,10] no overlap → ans = [[1,6], [8,10]]
    - [15,18] no overlap → ans = [[1,6], [8,10], [15,18]]
  output: [[1,6], [8,10], [15,18]]

time_complexity:
  sorting: O(n log n)
  merge_loop: O(n)
  total: O(n log n)

space_complexity:
  worst_case: O(n) for answer list if no intervals overlap

why_this_works:
  - Sorting ensures overlapping intervals are adjacent
  - Greedy merge ensures only necessary intervals are merged
  - We maintain the latest end time seen so far to check overlaps

notes:
  - Works only if intervals are sorted by start time
  - Using `ans.back()` allows constant-time access to last merged interval

6)maxSumCombinations:
  purpose: >
    To find the k largest sum combinations from two arrays nums1 and nums2,
    where each sum is formed by adding one element from nums1 and one from nums2.

  key_idea:
    - Sort both arrays in descending order to prioritize larger elements first.
    - Use a max-heap (priority_queue) to always extract the next largest combination.
    - Avoid duplicates by using a set to track visited index pairs (i, j).
    - Push neighboring combinations of the current pair to explore all possible top combinations.

  why_insert_both_neighbors:
    reason_1: "We are interested in the top-k largest sums — not just the next immediate maximum."
    reason_2: >
      Even if (i+1, j) has a greater sum than (i, j+1) now,
      the path from (i, j+1) might lead to even larger combinations later.
      Ignoring it could miss some of the actual top-k combinations.
    reason_3: >
      Both directions (i+1, j) and (i, j+1) represent different combination paths.
      Only pushing one of them can miss combinations involving nums1[i] with later nums2[j+1],
      or nums2[j] with later nums1[i+1].
    reason_4: >
      The max-heap takes care of ordering and selecting the next largest sum,
      so it's safe and optimal to explore both neighbors and let the heap manage which one to pick next.

  role_of_set:
    purpose: "To prevent visiting the same (i, j) index pair multiple times."
    ensures:
      - No duplicate sums are pushed into the heap.
      - Memory and computation are saved.
      - Correctness: prevents redundant computation and infinite loop.
    inserted_when:
      - After pushing (i+1, j) into pq, insert (i+1, j) into the set.
      - After pushing (i, j+1) into pq, insert (i, j+1) into the set.

  heap_invariant:
    - The max-heap always stores the current best unseen combinations.
    - It ensures that at each step, the largest possible sum is picked greedily.
    - By pushing both neighbors, the algorithm maintains correctness and completeness.

  correctness:
    - The algorithm guarantees that the top-k combinations are extracted in non-increasing order.
    - No combination is revisited.
    - All necessary potential candidates are explored due to the neighbor insertions.

  time_and_space_complexity:
    time: "O(k * log k + n log n) — dominated by heap operations and initial sorting"
    space: "O(k) for heap and visited set"

  conclusion: >
    Always push both neighbors (i+1, j) and (i, j+1) if they are within bounds and not visited.
    This ensures that no potential top-k sum is missed, and that the heap has all possible candidates to work with.

